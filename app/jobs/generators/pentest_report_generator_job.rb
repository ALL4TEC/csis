# frozen_string_literal: true

require 'tempfile'

module Generators
  # Pentest report generator
  class PentestReportGeneratorJob < ApplicationKubeJob
    # :reek:DuplicateMethodCall
    include ReportGeneratorCommon
    include ReportGeneratorCommonCore

    CERT_LOGO_PATH = AssetsUtil::CERTIFICATES_DIR.join('WSC_full.png')

    T_PENTESTS_RESULTS = 'pdf.pentest.title.results'
    T_PENTESTS_DETAILS = 'pdf.pentest.title.details'

    # Generation du rapport
    # @param report: Objet rapport contenant les données
    # @param path: chemin du nouveau document
    def generate_pdf(report, path)
      gen_pdf(report, path) do |summary_values|
        # Summary page creation, will fill-up at the end
        page_title(I18n.t('pdf.title.summary'), 'summary')
        summary_values.merge!(introduction(report))
        progressify(:introduction)
        summary_values.merge!(results(report))
        progressify(:results)
        summary_values.merge!(details(report))
        progressify(:details)
        summary_values.merge!(appendix(report)) if report.aggregates.appendix_kind.present?
        progressify(:appendix)
      end
    end

    private

    # Build underligned string
    def underline(arg)
      "<u>#{arg}</u>"
    end

    # Build the first page
    def flyleaf(report, date, location)
      @pdf.move_down 40
      @pdf.image CERT_LOGO_PATH, position: :center, width: 300
      @pdf.move_cursor_to 350
      @pdf.text(
        bold(report.project.name),
        inline_format: true,
        align: :center,
        size: 30
      )
      @pdf.move_down 10
      @pdf.text report.subtitle, align: :center, size: 20
      @pdf.move_down 20

      img = if report.client_logo.attached?
              StringIO.open(report.client_logo.download)
            else
              reports_logo
            end
      @pdf.image img, position: :center, height: 150
      flyleaf_common(report, date, location)
    end

    # Build Confidentiality Page
    def preambule(report)
      page_title(I18n.t('pdf.preamble').to_s, 'preliminary')
      @pdf.move_down 20

      @pdf.cell(size: 16,
        width: @pdf.bounds.width,
        content: report.introduction,
        border_color: ORANGE_CONFIDENTIEL)

      # Second page
      page_title(I18n.t('pdf.preamble').to_s, 'preliminary')
      @pdf.move_down 20

      @pdf.text(
        "#{I18n.t('pdf.classification.class_name')}: #{I18n.t(T_CONFIDENTIEL)}",
        inline_format: true,
        align: :left,
        color: ORANGE_CONFIDENTIEL,
        size: 18
      )
      preambule_common(report)
    end

    # Print summary lines at right places
    def add_summary_line(x_index, y_index, anchor, link, page)
      @pdf.grid(x_index, y_index).bounding_box do
        @pdf.text("<link anchor='#{anchor}'>#{link}" \
                  "#{I18n.t("pdf.pentest.title.#{anchor}")}</link>",
          inline_format: true, size: 20)
      end
      @pdf.grid(x_index, 0.875).bounding_box do
        @pdf.text page.to_s, size: 20, align: :right
      end
    end

    # Build summary with titles and page numbers
    def summary(titles)
      @pdf.go_to_page 4
      @pdf.move_down 130
      @pdf.define_grid(columns: 2, rows: 16)
      titles.each_with_index do |(key, values), index|
        x = values[:number].split('.').count
        add_summary_line(index + 2,
          (x * 0.025) + 0.1,
          key,
          values[:number] + ('     ' * (3 - x)),
          values[:page])
      end
    end

    def before_purpose_table(table)
      table.before_rendering_page do |page|
        basic_table_style(page)
      end
    end

    def purpose(report)
      @pdf.add_dest('purpose', @pdf.dest_xyz(@pdf.bounds.absolute_left, @pdf.y))
      data = [["1.1  #{I18n.t('pdf.pentest.title.purpose')}"]]
      data << [report.purpose]
      @pdf.table(data, cell_style: { size: 16 }) { |table| before_purpose_table(table) }
    end

    def before_exec_cond_table(table)
      table.before_rendering_page do |page|
        basic_table_style(page)
      end
    end

    def exec_cond(report)
      @pdf.add_dest('exec_cond', @pdf.dest_xyz(@pdf.bounds.absolute_left, @pdf.y))
      data = [["1.2  #{I18n.t('pdf.pentest.title.exec_cond')}"]]
      data << [report.exec_cond]
      @pdf.table(data, cell_style: { size: 16 }) { |table| before_exec_cond_table(table) }
    end

    def introduction(report)
      page_title(I18n.t('pdf.pentest.title.intro'), 'intro')

      summary_infos = {
        intro: { number: '1', page: @pdf.page_number },
        purpose: { number: '1.1', page: @pdf.page_number }
      }

      @pdf.move_down 20
      purpose(report)
      page_title(I18n.t('pdf.pentest.title.intro'), 'intro')
      summary_infos[:exec_cond] = { number: '1.2', page: @pdf.page_number }
      @pdf.move_down 20
      exec_cond(report)
      summary_infos
    end

    def fill_with_zero(tmp)
      tmp.append(content: '0', align: :right)
    end

    def handle_ref(report, total, data, ref)
      if (count = ref.aggregates.count).zero?
        tmp = [ref.name, { content: bold('0'), align: :right }]
        5.times { fill_with_zero(tmp) }
      else
        tmp = [ref.name, { content: bold(count.to_s), text_color: ORANGE, align: :right }]
        agg = ref.aggregates.where(report: report).group(:severity).count
        total[0] += count

        Aggregate.severities.drop(1).each do |sev, index|
          if agg[sev].blank?
            fill_with_zero(tmp)
            next
          end

          tmp.append(content: agg[sev].to_s, text_color: ORANGE, align: :right)
          total[index] += agg[sev]
        end
      end

      data << tmp
    end

    def before_top_table(table)
      table.before_rendering_page do |page|
        page.inline_format = true
      end
    end

    def handle_top(report, top)
      total = [0, 0, 0, 0, 0, 0]

      @pdf.move_down 20

      data = [[{ content: bold(top.name), colspan: 7, background_color: ORANGE,
                 align: :center }]]
      data << [{ content: bold(I18n.t('tops.labels.name')), rowspan: 2, background_color: ORANGE,
                 align: :center, valign: :center },
               { content: bold('#'), rowspan: 2, background_color: ORANGE, align: :center,
                 valign: :center },
               { content: bold(I18n.t('labels.severity')), colspan: 5, background_color: ORANGE,
                 align: :center }]
      data << [{ content: bold('1'), background_color: ORANGE, align: :center },
               { content: bold('2'), background_color: ORANGE, align: :center },
               { content: bold('3'), background_color: ORANGE, align: :center },
               { content: bold('4'), background_color: ORANGE, align: :center },
               { content: bold('5'), background_color: ORANGE, align: :center }]

      if top.references.present?
        top.references.find_each { |ref| handle_ref(report, total, data, ref) }

        data << [{ content: bold(I18n.t('pdf.pentest.text.total')), background_color: ORANGE,
                   align: :right },
                 { content: bold(total[0].to_s), background_color: ORANGE, align: :right },
                 { content: total[1].to_s, background_color: ORANGE, align: :right },
                 { content: total[2].to_s, background_color: ORANGE, align: :right },
                 { content: total[3].to_s, background_color: ORANGE, align: :right },
                 { content: total[4].to_s, background_color: ORANGE, align: :right },
                 { content: total[5].to_s, background_color: ORANGE, align: :right }]
      end

      # Width param breaks the table :/
      @pdf.table(data, cell_style: { size: 14 }) { |table| before_top_table(table) }
    end

    # Générations des tableaux de tops
    def handle_tops(report)
      report.tops.each { |top| handle_top(report, top) }
    end

    # Remplissage des couleurs de la table
    def fill_table_colors(table, col)
      Vulnerability.severities.keys.reverse.map(&:to_sym).each_with_index do |sev, j|
        table.row(j).column(col).background_color = AggregatesHelper.color_fill_severity(sev)
        table.row(j).column(col).text_color = AggregatesHelper.color_text_severity(sev)
      end
    end

    def before_levels_table(table, report)
      color = Vulnerability.severities.keys.reverse[report.level_before_type_cast]
      table.before_rendering_page do |page|
        page.border_width = 0
        page.column(1).text_color = AggregatesHelper.color_text_severity(color)
        page.column(1).background_color = AggregatesHelper.color_fill_severity(color)
      end
    end

    def before_managerial_summary_table(table)
      table.before_rendering_page do |page|
        basic_table_style(page)
      end
    end

    def managerial_summary(report)
      @pdf.add_dest('managerial_summary', @pdf.dest_xyz(@pdf.bounds.absolute_left, @pdf.y))
      data = [["2.1  #{I18n.t('pdf.pentest.title.managerial_summary')}"]]
      levels_table = @pdf.make_table(
        [
          [
            I18n.t('pdf.pentest.text.observed_level'),
            I18n.t("statistics.labels.nof_#{report.level}")
          ]
        ],
        cell_style: { size: 16 }
      ) { |table| before_levels_table(table, report) }
      data << [levels_table]
      data << [report.results]

      @pdf.table(data, cell_style: { inline_format: true, size: 16 }) do |table|
        before_managerial_summary_table(table)
      end
    end

    def tech_synth(report)
      @pdf.column_box([10, 525], columns: 1, width: 1030, height: 470) do
        @pdf.move_down 20
        @pdf.add_dest('tech_synth', @pdf.dest_xyz(@pdf.bounds.absolute_left, @pdf.y))
        @pdf.text(
          "2.2  #{I18n.t('pdf.pentest.title.tech_synth')}",
          size: 16,
          align: :left,
          color: GREY
        )
        handle_tops(report) if report.tops.present?
      end
    end

    def before_audit_scale_table(table)
      table.before_rendering_page do |page|
        page.border_width = 0
        page.align = :left
        fill_table_colors(page, 1)
      end
    end

    def audit_scale
      @pdf.text(
        underline(I18n.t('pdf.pentest.text.audit_scale')),
        size: 14,
        align: :left,
        inline_format: true
      )
      @pdf.move_down 10

      data = []
      Report.levels.each do |level, index|
        str = if index.zero?
                I18n.t('pdf.pentest.text.vuln_level_five')
              else
                I18n.t('pdf.pentest.text.vuln_level_other', level: 5 - index)
              end
        data << [str, I18n.t("statistics.labels.nof_#{level}")]
      end

      @pdf.table(data, cell_style: { size: 14 }) { |table| before_audit_scale_table(table) }
    end

    def before_correction_time_table(table)
      table.before_rendering_page do |page|
        page.border_width = 0
        page.align = :left
        fill_table_colors(page, 1)
      end
    end

    def correction_time
      @pdf.text(
        underline(I18n.t('pdf.pentest.text.correction_time')),
        position: :right,
        size: 14,
        align: :left,
        inline_format: true
      )
      @pdf.move_down 10

      data = []
      Vulnerability.severities.reverse_each do |sev, index|
        data << [
          I18n.t('pdf.pentest.text.level', level: 5 - index),
          AggregatesHelper.translate_severity(sev)
        ]
      end

      @pdf.table(data, cell_style: { size: 14 }) { |table| before_correction_time_table(table) }
    end

    def before_complexity_table(table)
      table.before_rendering_page do |page|
        page.border_width = 0
        page.align = :left
      end
    end

    def complexity
      @pdf.text(
        underline(I18n.t('pdf.pentest.text.complexity')),
        size: 14,
        align: :left,
        inline_format: true
      )

      @pdf.move_down 10

      data = []

      %w[low medium high].each do |level|
        data << [I18n.t("pdf.pentest.level.#{level}")]
      end

      @pdf.table(data, cell_style: { size: 14 }) { |table| before_complexity_table(table) }
    end

    def before_tools_table(table)
      table.before_rendering_page do |page|
        page.column(0).align = :left
        page.row(0).align = :center
        page.column(1).align = :center
        page.row(0).background_color = ORANGE
      end
    end

    def tools(report)
      @pdf.add_dest('tools', @pdf.dest_xyz(@pdf.bounds.absolute_left, @pdf.y))
      @pdf.text(
        "2.3  #{I18n.t('pdf.pentest.title.tools')}",
        size: 16,
        align: :left,
        color: GREY
      )

      @pdf.move_down 20

      data = [[I18n.t('reports.labels.tools.name'), I18n.t('reports.labels.tools.version')]]
      if report.tools.present?
        JSON.parse(report.tools).each do |tool|
          data << [tool['name'], tool['version']]
        end
      end

      @pdf.table(data, position: :center, column_widths: [700, 300],
        cell_style: { size: 14 }) do |table|
        before_tools_table(table)
      end
    end

    # @return summary_infos
    def results(report)
      # Page 1
      page_title(I18n.t(T_PENTESTS_RESULTS), 'results')

      summary_infos = {
        results: { number: '2', page: @pdf.page_number },
        managerial_summary: { number: '2.1', page: @pdf.page_number }
      }

      @pdf.move_down 20
      managerial_summary(report)

      # Page 2
      page_title(I18n.t(T_PENTESTS_RESULTS), 'results')
      first_page_nb = @pdf.page_number
      summary_infos[:tech_synth] = { number: '2.2', page: first_page_nb }
      tech_synth(report)
      last_page_nb = @pdf.page_number
      add_titles_numbering(first_page_nb, last_page_nb, I18n.t(T_PENTESTS_RESULTS))

      # Page 3
      page_title(I18n.t(T_PENTESTS_RESULTS), 'results')
      @pdf.move_down 20
      y = @pdf.cursor
      @pdf.span(400, position: :left) do
        audit_scale
      end

      @pdf.move_cursor_to y

      @pdf.span(400, position: 450) do
        correction_time
      end

      @pdf.move_cursor_to y

      @pdf.span(200, position: :right) do
        complexity
      end

      # Page 4
      page_title(I18n.t(T_PENTESTS_RESULTS), 'results')
      summary_infos[:tools] = { number: '2.3', page: @pdf.page_number }
      @pdf.move_down 20
      tools(report)

      summary_infos
    end

    def add_titles_numbering(first_page_nb, last_page_nb, vuln_type)
      current_page = first_page_nb
      while current_page <= last_page_nb
        @pdf.go_to_page current_page
        @pdf.text vuln_type, size: 25
        @pdf.stroke_color 'B95D33'
        @pdf.line [0, 540], [@pdf.bounds.right, 540]
        @pdf.stroke
        @pdf.move_down 20
        @pdf.stroke_color BLACK
        current_page += 1
      end
    end

    def aggregate_content(agg)
      @pdf.move_down 20
      draw_aggregate_contents(agg)
    end

    def aggregates_content(report)
      @pdf.move_down 20
      @pdf.add_dest('scan', @pdf.dest_xyz(@pdf.bounds.absolute_left, @pdf.y))
      @pdf.text(
        "3.1  #{I18n.t('pdf.pentest.title.scan')}",
        size: 16,
        align: :left,
        color: GREY
      )

      report.aggregates.vulnerability_scan_kind.order('rank ASC').each do |agg|
        aggregate_content(agg)
      end
    end

    def pentest(report)
      @pdf.move_down 20

      @pdf.add_dest('pentest', @pdf.dest_xyz(@pdf.bounds.absolute_left, @pdf.y))
      @pdf.text(
        "3.2  #{I18n.t('pdf.pentest.title.pentest')}",
        size: 16,
        align: :left,
        color: GREY
      )

      each_aggregate_kind do |kind, _i|
        aggregates(
          report.aggregates.where(kind: kind, visibility: :shown).order(:rank)
        )
        Rails.logger.info "Generated; section='#{kind.capitalize} Aggregates'"
      end
    end

    # @return summary_infos
    def details(report)
      # Page 1
      page_title(I18n.t(T_PENTESTS_DETAILS), 'details')
      summary_infos = {
        details: { number: '3', page: @pdf.page_number },
        scan: { number: '3.1', page: @pdf.page_number }
      }

      first_page_nb = @pdf.page_number
      @pdf.column_box([10, 525], columns: 1, width: 1030, height: 470) do
        aggregates_content(report)
      end

      # Page 2
      page_title(I18n.t(T_PENTESTS_DETAILS), 'details')
      summary_infos[:pentest] = { number: '3.2', page: @pdf.page_number }
      @pdf.column_box([10, 525], columns: 2, width: 1030, height: 470) do
        pentest(report)
      end

      last_page_nb = @pdf.page_number
      add_titles_numbering(first_page_nb, last_page_nb, I18n.t(T_PENTESTS_DETAILS))

      summary_infos
    end

    def before_aggregate_left_table(table)
      table.before_rendering_page do |page|
        page.text_color = ORANGE
        page.borders = []
        page.width = 300
      end
    end

    def before_aggregate_right_table(table, severity)
      table.before_rendering_page do |page|
        page.text_color = AggregatesHelper.color_text_severity(severity)
        page.background_color = AggregatesHelper.color_fill_severity(severity)
        page.width = 300
      end
    end

    def before_aggregate_data_table(table)
      table.before_rendering_page do |page|
        # page.height = nil # Si absent -> trop de bottom padding ...
        page.align = :left
        page.border_color = ORANGE
        page.width = 400
        page.row(0).border_top_width = 1
        page.row(-1).border_bottom_width = 1
        page.column(0).border_left_width = 1
        page.column(-1).border_right_width = 1
      end
    end

    def draw_aggregate_data(agg)
      aggregate_data = []
      aggregate_data <<
        ["#{I18n.t('pdf.pentest.aggregates.impact')} <color rgb='FF9B06'>#{agg.impact}</color>"]
      if agg.complexity.present?
        aggregate_data << ["#{I18n.t('pdf.pentest.aggregates.complexity')} " \
                           "<color rgb='FF9B06'>#{agg.complexity}</color>"]
      end
      agg.references.find_each do |ref|
        aggregate_data << ["#{I18n.t('pdf.pentest.aggregates.reference',
          top: ref.top)} #{ref}"]
      end

      @pdf.table(aggregate_data, cell_style: { inline_format: true, border_width: 0,
                                               size: 14 }) do |table|
        before_aggregate_data_table(table)
      end
    end

    def draw_aggregate_contents(agg)
      agg.contents.each { |content| draw_aggregate_content(content) }
    end

    def draw_aggregate_content(content)
      if content.text.present?
        @pdf.move_down 20
        @pdf.text(
          content.text,
          size: 14,
          align: :justify
        )
      end
      return unless content.image.attached?

      @pdf.move_down 20
      @pdf.image StringIO.open(content.image.download), position: :center, fit: [500, 470]
    end

    def before_aggregate_solution_table(table)
      table.before_rendering_page do |page|
        page.border_color = ORANGE
        page.width = 400
        page.height = nil # Si absent + solution longue -> écrase la fin ...
      end
    end

    def draw_aggregate_solution(agg)
      return if agg.solution.blank?

      @pdf.text(
        underline(I18n.t('labels.solution')),
        size: 14,
        inline_format: true
      )
      @pdf.move_down 10
      @pdf.table([[agg.solution]], cell_style: { size: 14 }) do |table|
        before_aggregate_solution_table(table)
      end
      @pdf.move_down 20
    end

    def draw_aggregate_scope(agg)
      return if agg.scope.blank?

      @pdf.text(
        underline(I18n.t('labels.scope')),
        size: 14,
        inline_format: true
      )
      @pdf.move_down 10
      @pdf.text(
        agg.scope,
        align: :left,
        width: 400,
        size: 14
      )
      @pdf.move_down 20
    end

    def draw_aggregate(agg)
      @pdf.move_down 20

      # Splitté car quand le moitié de la table est à gauche et l'autre à droite,
      # le style de la 1ere colonne est appliqué aux 2
      @pdf.table([[agg.title]], cell_style: { size: 18 }) do |table|
        before_aggregate_left_table(table)
      end
      @pdf.table(
        [[AggregatesHelper.translate_severity(agg.severity)]], cell_style: { size: 16 }
      ) do |table|
        before_aggregate_right_table(table, agg.severity)
      end

      @pdf.move_down 20
      draw_aggregate_data(agg)
      draw_aggregate_contents(agg)
      @pdf.move_down 20
      draw_aggregate_solution(agg)
      draw_aggregate_scope(agg)
    end

    # Create aggregates pages : its descriptions and misc infos + page numbering
    def aggregates(aggregates)
      current_agg = 0
      aggregates.each do |agg|
        draw_aggregate(agg)
        current_agg += 1
      end
    end

    def before_appendixes_table(table)
      table.before_rendering_page do |page|
        page.text_color = GREY
        page.borders = []
        page.width = 300
      end
    end

    def draw_appendix(agg)
      @pdf.move_down 20
      @pdf.table([[agg.title]], cell_style: { size: 18 }) do |table|
        before_appendixes_table(table)
      end
      @pdf.move_down 20
      draw_aggregate_contents(agg)
    end

    def draw_appendixes(report)
      report.aggregates.appendix_kind.order('rank ASC').each { |agg| draw_appendix(agg) }
    end

    # @return summary_infos
    def appendix(report)
      # Page 1
      page_title(I18n.t('pdf.pentest.title.appendix'), 'appendix')
      summary_infos = { appendix: { number: '4', page: @pdf.page_number } }
      first_page_nb = @pdf.page_number

      @pdf.column_box([10, 525], columns: 1, width: 1030, height: 470) do
        draw_appendixes(report)
      end

      last_page_nb = @pdf.page_number
      add_titles_numbering(first_page_nb, last_page_nb, I18n.t('pdf.pentest.title.appendix'))

      summary_infos
    end

    # Generate last page and its message
    def last_page_message(note)
      page_title('', '')
      @pdf.move_cursor_to 500
      @pdf.text note.to_s, size: 17 if note.present?
      @pdf.move_down 40
      @pdf.text(
        bold(I18n.t('pdf.pentest.text.end')),
        size: 20,
        align: :center,
        inline_format: true
      )
    end

    # Basic style for tables
    def basic_table_style(page)
      page.border_width = 0
      page.row(0).align = :left
      page.row(1).align = :justify
      page.width = 1030
      page.row(0).text_color = GREY
    end

    def yield_generate(export, filepath, _archi, _histo)
      generate_pdf(export.report, filepath)
    end

    # Lance la génération du pdf
    # @param export_id: identifiant d'export du pdf
    def perform(export_id)
      return unless Rails.application.config.pentest_enabled

      handle_perform(11, export_id)
    end
  end
end
